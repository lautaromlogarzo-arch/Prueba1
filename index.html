<<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FSAE Suspension Analyzer</title>
    
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

    <style>
        /* --- ESTILO TIPO STREAMLIT DARK MODE --- */
        :root {
            --bg-color: #0e1117;
            --sidebar-bg: #262730;
            --text-color: #fafafa;
            --text-gray: #c0c0c0;
            --accent-color: #ff4b4b;
            --border-color: #464855;
            --input-bg: #31333F;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            font-size: 14px;
        }

        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }

        /* --- BARRA LATERAL (SIDEBAR) --- */
        .sidebar {
            width: 350px;
            min-width: 350px;
            background-color: var(--sidebar-bg);
            padding: 2rem 1.5rem;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .sidebar h2 {
            color: var(--text-color);
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            margin-top: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        .input-group { margin-bottom: 10px; }
        .input-group label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: var(--text-color);
        }

        /* Inputs estandarizados */
        input[type="number"], select {
            width: 100%;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        input[type="number"]:focus { outline: 1px solid var(--accent-color); }

        /* Sliders */
        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-color);
        }

        /* Inputs de coordenadas (3 en fila) */
        .coord-row { display: flex; gap: 5px; }
        .coord-row input { width: 33%; font-size: 0.8rem; padding: 5px; }

        .info-box {
            background-color: rgba(60, 100, 255, 0.1);
            border: 1px solid rgba(60, 100, 255, 0.4);
            color: #a8caff;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        /* --- CONTENIDO PRINCIPAL --- */
        .main {
            flex: 1;
            padding: 2rem 3rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 { font-weight: 600; margin-bottom: 5px; }
        .subtitle { color: var(--text-gray); margin-bottom: 20px; }

        /* Layout de columnas para resultados y gr√°fico */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            height: 100%;
        }

        /* Contenedor del gr√°fico */
        .plot-container {
            background-color: #161a24; /* Color de fondo del plot */
            border-radius: 8px;
            border: 1px solid var(--border-color);
            height: 600px;
            position: relative;
        }

        /* Tabla de resultados */
        .results-panel {
            background-color: var(--sidebar-bg);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        th {
            text-align: left;
            border-bottom: 2px solid var(--border-color);
            padding: 8px 0;
            color: var(--text-gray);
        }

        td {
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .status-ok { color: #00cc66; font-weight: bold; }
        .status-fail { color: #ff4b4b; font-weight: bold; }

        /* Radio buttons customizados para el modo */
        .mode-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <h2>1. Masas y Distribuci√≥n</h2>
        <div class="input-group">
            <label>Masa Veh√≠culo (kg)</label>
            <input type="number" id="m_vehiculo" value="300" oninput="updateApp()">
        </div>
        <div class="input-group">
            <label>Masa Piloto (kg)</label>
            <input type="number" id="m_piloto" value="65" oninput="updateApp()">
        </div>
        <div class="input-group">
            <label>Distribuci√≥n Delantera (%) <span id="dist_val">40%</span></label>
            <input type="range" id="weight_dist" min="0" max="100" value="40" oninput="updateApp()">
        </div>

        <h2>2. Geometr√≠a (Hardpoints [m])</h2>
        <div class="info-box">Coordenadas X, Y, Z</div>

        <div id="geometry-inputs">
            </div>

        <h2>3. Material y Tubos</h2>
        <div class="input-group">
            <label>L√≠mite El√°stico (MPa)</label>
            <input type="number" id="yield_str" value="310" oninput="updateApp()">
        </div>
        <div class="input-group">
            <label>M√≥dulo Young (GPa)</label>
            <input type="number" id="young_mod" value="210" oninput="updateApp()">
        </div>
        <div class="input-group">
            <label>Di√°metro Ext (mm)</label>
            <input type="number" id="od_mm" value="20" oninput="updateApp()">
        </div>
        <div class="input-group">
            <label>Di√°metro Int (mm)</label>
            <input type="number" id="id_mm" value="0" oninput="updateApp()">
        </div>
        <div class="input-group">
            <label>FS Objetivo</label>
            <input type="number" id="sf_target" value="3.5" oninput="updateApp()">
        </div>

        <h2>4. Din√°mica (G's)</h2>
        <div class="input-group"><label>G's Frenado</label><input type="range" id="g_brake" min="0" max="3" step="0.1" value="1.7" oninput="updateApp()"> <span id="val_g_brake">1.7</span></div>
        <div class="input-group"><label>G's Curva</label><input type="range" id="g_corn" min="0" max="3" step="0.1" value="2.0" oninput="updateApp()"> <span id="val_g_corn">2.0</span></div>
        <div class="input-group"><label>G's Bump</label><input type="range" id="g_bump" min="1" max="5" step="0.1" value="3.0" oninput="updateApp()"> <span id="val_g_bump">3.0</span></div>
        
        <div class="input-group"><label>Altura CG (m)</label><input type="number" id="h_cg" value="0.35" oninput="updateApp()"></div>
        <div class="input-group"><label>Wheelbase (m)</label><input type="number" id="w_base" value="1.65" oninput="updateApp()"></div>
        <div class="input-group"><label>Track Width (m)</label><input type="number" id="track_w" value="1.20" oninput="updateApp()"></div>
    </div>

    <div class="main">
        <div>
            <h1>üèéÔ∏è FSAE Suspension Stress & Geometry Analyzer</h1>
            <div class="subtitle">Ajusta los puntos y par√°metros para ver el an√°lisis en tiempo real.</div>
        </div>

        <div class="dashboard-grid">
            <div class="plot-container" id="plot3d"></div>

            <div class="results-panel">
                <h3>Resultados</h3>
                <div class="input-group">
                    <label>Modo de Carga:</label>
                    <select id="load_mode" onchange="updateApp()">
                        <option value="static">Est√°tico (1G Vertical)</option>
                        <option value="dynamic">Din√°mico (Frenado + Curva + Bump)</option>
                    </select>
                </div>

                <div id="results-table-container">
                    </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACI√ìN INICIAL Y PUNTOS ---
        
        // Puntos por defecto (Exactamente los de tu Python)
        const defaultPoints = {
            tire_FL: [0.0, 0.5867, 0.2525],
            lwb_ch_f: [-0.0799, 0.2645, 0.1252],
            lwb_ch_r: [0.0799, 0.2645, 0.1252],
            uwb_ch_f: [-0.0543, 0.2425, 0.2888],
            uwb_ch_r: [0.0930, 0.2425, 0.2728],
            lwb_up: [0.0, 0.5843, 0.1485],
            uwb_up: [0.0301, 0.5538, 0.3565],
            push_ch: [0.0, 0.2000, 0.5000],
            push_up: [0.0, 0.5000, 0.2500],
            tie_ch: [-0.100, 0.270, 0.160],
            tie_up: [-0.100, 0.520, 0.160]
        };

        const pointLabels = {
            tire_FL: "Centro Rueda",
            lwb_ch_f: "LWB Chasis Front",
            lwb_ch_r: "LWB Chasis Rear",
            uwb_ch_f: "UWB Chasis Front",
            uwb_ch_r: "UWB Chasis Rear",
            lwb_up: "LWB Upright (LBJ)",
            uwb_up: "UWB Upright (UBJ)",
            push_ch: "Pushrod Chasis",
            push_up: "Pushrod Upright",
            tie_ch: "Tie-Rod Chasis",
            tie_up: "Tie-Rod Upright"
        };

        // Generar Inputs HTML din√°micamente
        const geoContainer = document.getElementById('geometry-inputs');
        for (const [key, val] of Object.entries(defaultPoints)) {
            const div = document.createElement('div');
            div.className = 'input-group';
            div.innerHTML = `
                <label>${pointLabels[key]}</label>
                <div class="coord-row">
                    <input type="number" id="${key}_x" value="${val[0]}" step="0.001" oninput="updateApp()">
                    <input type="number" id="${key}_y" value="${val[1]}" step="0.001" oninput="updateApp()">
                    <input type="number" id="${key}_z" value="${val[2]}" step="0.001" oninput="updateApp()">
                </div>
            `;
            geoContainer.appendChild(div);
        }

        // --- 2. FUNCIONES MATEM√ÅTICAS (√Ålgebra Lineal) ---

        // Obtener coordenadas actuales de los inputs
        function getPoint(key) {
            return [
                parseFloat(document.getElementById(`${key}_x`).value),
                parseFloat(document.getElementById(`${key}_y`).value),
                parseFloat(document.getElementById(`${key}_z`).value)
            ];
        }

        // Vector unitario
        function getUnitVector(p1, p2) {
            const v = math.subtract(p2, p1);
            const mag = math.norm(v);
            return math.divide(v, mag);
        }

        // --- 3. L√ìGICA PRINCIPAL (C√°lculo de Fuerzas) ---
        function solveSuspension() {
            // Recoger Inputs
            const m_veh = parseFloat(document.getElementById('m_vehiculo').value);
            const m_pil = parseFloat(document.getElementById('m_piloto').value);
            const dist = parseFloat(document.getElementById('weight_dist').value) / 100;
            const isDynamic = document.getElementById('load_mode').value === 'dynamic';
            
            // Puntos
            const p = {};
            for (const k of Object.keys(defaultPoints)) p[k] = getPoint(k);

            // Din√°mica
            const g = 9.81;
            const total_mass = m_veh + m_pil;
            let Fx_g = 0, Fy_g = 0, Fz_g = 0;

            if (!isDynamic) {
                // Est√°tico
                const mass_corner = (total_mass * dist) / 2;
                Fz_g = mass_corner * g;
            } else {
                // Din√°mico
                const g_brake = parseFloat(document.getElementById('g_brake').value);
                const g_corn = parseFloat(document.getElementById('g_corn').value);
                const g_bump = parseFloat(document.getElementById('g_bump').value);
                const h_cg = parseFloat(document.getElementById('h_cg').value);
                const wb = parseFloat(document.getElementById('w_base').value);
                const tw = parseFloat(document.getElementById('track_w').value);

                const trans_long = (total_mass * g_brake * h_cg) / wb;
                const axle_front = (total_mass * dist) + trans_long;
                const trans_lat = (axle_front * g_corn * h_cg) / tw;
                const mass_fl = (axle_front / 2) + trans_lat;

                Fz_g = mass_fl * g * g_bump;
                // Simplificaci√≥n de adherencia similar a tu c√≥digo
                Fx_g = -Math.min(mass_fl * g * g_brake, Fz_g);
                Fy_g = Math.min(mass_fl * g * g_corn, Fz_g);
            }

            // --- CONSTRUCCI√ìN DEL SISTEMA Ax = B ---
            // Inc√≥gnitas: [F_lwbf, F_lwbr, F_uwbf, F_uwbr, F_push, F_tie]
            
            // 1. Calcular vectores directores (Unitarios)
            // Nota: En tu c√≥digo Python los vectores van de CHASIS a UPRIGHT para el equilibrio en el Upright
            // Suma de fuerzas en el Upright = 0
            // F_link + F_ground = 0  => F_link = -F_ground (Si F_link es la fuerza del link SOBRE el upright)
            
            const u_lwbf = getUnitVector(p.lwb_ch_f, p.lwb_up);
            const u_lwbr = getUnitVector(p.lwb_ch_r, p.lwb_up);
            const u_uwbf = getUnitVector(p.uwb_ch_f, p.uwb_up);
            const u_uwbr = getUnitVector(p.uwb_ch_r, p.uwb_up);
            const u_push = getUnitVector(p.push_ch, p.push_up);
            const u_tie  = getUnitVector(p.tie_ch, p.tie_up);

            // 2. Brazos de momento respecto al centro de rueda (Ref)
            const ref = p.tire_FL;
            const r_lwb = math.subtract(p.lwb_up, ref);
            const r_uwb = math.subtract(p.uwb_up, ref);
            const r_push = math.subtract(p.push_up, ref);
            const r_tie = math.subtract(p.tie_up, ref);
            const r_ground = math.subtract([ref[0], ref[1], 0], ref); // Contact patch a centro

            // 3. Matriz A (Coeficientes)
            // Columnas: LWB_F, LWB_R, UWB_F, UWB_R, Push, Tie
            // Filas 0-2: Componentes X, Y, Z de los vectores unitarios
            // Filas 3-5: Componentes X, Y, Z de los momentos (r cruz u)

            const m_lwbf = math.cross(r_lwb, u_lwbf);
            const m_lwbr = math.cross(r_lwb, u_lwbr);
            const m_uwbf = math.cross(r_uwb, u_uwbf);
            const m_uwbr = math.cross(r_uwb, u_uwbr);
            const m_push = math.cross(r_push, u_push);
            const m_tie  = math.cross(r_tie, u_tie);

            const A = [
                [u_lwbf[0], u_lwbr[0], u_uwbf[0], u_uwbr[0], u_push[0], u_tie[0]], // Fx
                [u_lwbf[1], u_lwbr[1], u_uwbf[1], u_uwbr[1], u_push[1], u_tie[1]], // Fy
                [u_lwbf[2], u_lwbr[2], u_uwbf[2], u_uwbr[2], u_push[2], u_tie[2]], // Fz
                [m_lwbf[0], m_lwbr[0], m_uwbf[0], m_uwbr[0], m_push[0], m_tie[0]], // Mx
                [m_lwbf[1], m_lwbr[1], m_uwbf[1], m_uwbr[1], m_push[1], m_tie[1]], // My
                [m_lwbf[2], m_lwbr[2], m_uwbf[2], m_uwbr[2], m_push[2], m_tie[2]]  // Mz
            ];

            // 4. Vector B (Fuerzas externas conocidas, pasadas al otro lado: -F_ground)
            const F_ground = [Fx_g, Fy_g, Fz_g];
            const M_ground = math.cross(r_ground, F_ground);

            // Como la ec es: Sum(F_links) + F_ground = 0  -> Sum(F_links) = -F_ground
            const B = [
                -F_ground[0], -F_ground[1], -F_ground[2],
                -M_ground[0], -M_ground[1], -M_ground[2]
            ];

            // 5. Resolver Ax = B
            let x;
            try {
                x = math.lusolve(A, B); // Devuelve array de arrays [[val], [val]...]
                x = math.flatten(x); // Convertir a array simple
            } catch (error) {
                console.error("Matriz singular o error num√©rico", error);
                return null;
            }

            // Mapear resultados
            return [
                { name: "LWB Front", force: x[0], p1: p.lwb_ch_f, p2: p.lwb_up },
                { name: "LWB Rear",  force: x[1], p1: p.lwb_ch_r, p2: p.lwb_up },
                { name: "UWB Front", force: x[2], p1: p.uwb_ch_f, p2: p.uwb_up },
                { name: "UWB Rear",  force: x[3], p1: p.uwb_ch_r, p2: p.uwb_up },
                { name: "Pushrod",   force: x[4], p1: p.push_ch, p2: p.push_up },
                { name: "Tie-Rod",   force: x[5], p1: p.tie_ch, p2: p.tie_up }
            ];
        }

        // --- 4. ACTUALIZACI√ìN DE UI Y GR√ÅFICOS ---

        function updateApp() {
            // Actualizar etiquetas de sliders
            document.getElementById('dist_val').innerText = document.getElementById('weight_dist').value + '%';
            document.getElementById('val_g_brake').innerText = document.getElementById('g_brake').value;
            document.getElementById('val_g_corn').innerText = document.getElementById('g_corn').value;
            document.getElementById('val_g_bump').innerText = document.getElementById('g_bump').value;

            // Calcular
            const results = solveSuspension();

            if (!results) {
                document.getElementById('results-table-container').innerHTML = "<div class='status-fail'>Error: Sistema Singular o Geometr√≠a Inv√°lida</div>";
                return;
            }

            // Material
            const yield_str = parseFloat(document.getElementById('yield_str').value);
            const young = parseFloat(document.getElementById('young_mod').value);
            const od = parseFloat(document.getElementById('od_mm').value);
            const id = parseFloat(document.getElementById('id_mm').value);
            const area = (Math.PI / 4) * (Math.pow(od, 2) - Math.pow(id, 2));
            const inertia = (Math.PI / 64) * (Math.pow(od, 4) - Math.pow(id, 4));

            // Generar Tabla
            let tableHTML = `<table><thead><tr><th>Miembro</th><th>Fuerza [N]</th><th>Stress [MPa]</th><th>FS Fluencia</th><th>FS Pandeo</th></tr></thead><tbody>`;
            
            results.forEach(item => {
                const f = item.force;
                const length_mm = math.distance(item.p1, item.p2) * 1000;
                
                const stress = Math.abs(f) / area;
                const fs_yield = stress > 0 ? (yield_str / stress) : 999;
                
                let fs_buckling = "N/A";
                let buck_class = "";
                
                // Pandeo (Solo compresi√≥n, F > 0 seg√∫n convenci√≥n de resoluci√≥n si vector va de chasis a upright y da positivo)
                // Chequeo de signo: Si definimos vectores Chasis->Upright, y la fuerza da positiva, el link empuja al upright (compresi√≥n).
                if (f > 0) {
                    const P_crit = (Math.PI**2 * (young * 1000) * inertia) / (length_mm**2);
                    const val_b = P_crit / f;
                    fs_buckling = val_b.toFixed(2);
                    buck_class = val_b < parseFloat(document.getElementById('sf_target').value) ? "status-fail" : "status-ok";
                }

                tableHTML += `
                    <tr>
                        <td>${item.name}</td>
                        <td>${f.toFixed(1)}</td>
                        <td>${stress.toFixed(1)}</td>
                        <td class="${fs_yield < parseFloat(document.getElementById('sf_target').value) ? 'status-fail' : 'status-ok'}">${fs_yield.toFixed(2)}</td>
                        <td class="${buck_class}">${fs_buckling}</td>
                    </tr>
                `;
            });
            tableHTML += "</tbody></table>";
            document.getElementById('results-table-container').innerHTML = tableHTML;

            updatePlot(results);
        }

        function updatePlot(results) {
            const traces = [];
            const p = {};
            for (const k of Object.keys(defaultPoints)) p[k] = getPoint(k);

            // Funci√≥n auxiliar para crear l√≠neas
            const addLine = (p1, p2, name, color, width=4) => {
                traces.push({
                    x: [p1[0], p2[0]], y: [p1[1], p2[1]], z: [p1[2], p2[2]],
                    mode: 'lines+markers',
                    type: 'scatter3d',
                    name: name,
                    line: {color: color, width: width},
                    marker: {size: 3, color: 'black'}
                });
            };

            // Dibujar Geometr√≠a
            addLine(p.lwb_ch_f, p.lwb_up, "LWB Front", '#3366ff');
            addLine(p.lwb_ch_r, p.lwb_up, "LWB Rear", '#3366ff');
            addLine(p.uwb_ch_f, p.uwb_up, "UWB Front", '#ff3333');
            addLine(p.uwb_ch_r, p.uwb_up, "UWB Rear", '#ff3333');
            addLine(p.push_ch, p.push_up, "Pushrod", '#00cc66', 8);
            addLine(p.tie_ch, p.tie_up, "Tie-Rod", '#ff9900');
            addLine(p.lwb_up, p.uwb_up, "Upright", 'white', 6);

            // Rueda
            traces.push({
                x: [p.tire_FL[0]], y: [p.tire_FL[1]], z: [p.tire_FL[2]],
                mode: 'markers', type: 'scatter3d', name: 'Rueda',
                marker: {size: 10, color: 'white'}
            });

            const layout = {
                paper_bgcolor: '#161a24',
                plot_bgcolor: '#161a24',
                scene: {
                    aspectmode: 'data',
                    xaxis: {title: 'X', color: 'white', gridcolor: '#444'},
                    yaxis: {title: 'Y', color: 'white', gridcolor: '#444'},
                    zaxis: {title: 'Z', color: 'white', gridcolor: '#444'},
                    camera: { eye: {x: 1.5, y: 1.5, z: 1.5} }
                },
                margin: {l: 0, r: 0, b: 0, t: 0},
                showlegend: true,
                legend: {x: 0, y: 1, font: {color: 'white'}}
            };

            Plotly.react('plot3d', traces, layout);
        }

        // Inicializar
        updateApp();

        // Auto-ajuste de tama√±o del plot al cambiar ventana
        window.onresize = function() {
            Plotly.Plots.resize(document.getElementById('plot3d'));
        };

    </script>
</body>
</html>