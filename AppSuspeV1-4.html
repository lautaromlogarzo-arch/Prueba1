<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador FSAE - Vehículo Completo</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    
    <style>
        :root { --primary: #d62828; --dark: #003049; --light: #fdf0d5; --accent: #669bbc; --chassis: #7f8c8d; }
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; background: #edf2f4; display: flex; height: 100vh; overflow: hidden; }
        
        /* Layout */
        .sidebar { width: 450px; background: #fff; overflow-y: auto; padding: 20px; box-shadow: 4px 0 15px rgba(0,0,0,0.1); z-index: 10; display: flex; flex-direction: column; border-right: 1px solid #ddd; }
        .main-content { flex: 1; display: flex; flex-direction: column; position: relative; }
        .viz-container { flex: 1; position: relative; background: #dae3e7; }
        .results-panel { height: 280px; background: var(--dark); color: #eee; overflow-y: auto; padding: 15px 25px; font-family: 'Consolas', monospace; font-size: 0.85rem; border-top: 4px solid var(--primary); }

        /* Estilos UI */
        h2 { color: var(--dark); border-bottom: 3px solid var(--primary); padding-bottom: 10px; margin-bottom: 15px; font-size: 1.2rem; text-transform: uppercase; }
        h4 { margin: 12px 0 5px 0; color: var(--accent); font-size: 0.85rem; text-transform: uppercase; border-bottom: 1px solid #eee; padding-bottom: 2px;}
        .section-header { font-weight: bold; color: var(--dark); margin-top: 15px; margin-bottom: 5px; display: block; font-size: 0.95em; background: #f0f4f8; padding: 5px; border-radius: 4px;}

        .input-group { background: #f8f9fa; padding: 8px; border-radius: 6px; border: 1px solid #e9ecef; margin-bottom: 8px; }
        .row { display: flex; gap: 8px; align-items: center; margin-bottom: 4px; }
        .row label { flex: 1.6; font-size: 0.8rem; font-weight: 600; color: #444; }
        .row input, .row select { flex: 1; padding: 4px 6px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.85rem; }
        .row input[type="color"] { padding: 0; height: 25px; }
        .coord-inputs { display: flex; gap: 2px; flex: 2; }
        .coord-inputs input { width: 100%; text-align: center; font-family: monospace; font-weight: 500; font-size: 0.8rem; }
        .calc-button { width: 100%; padding: 12px; background: var(--primary); color: white; border: none; cursor: pointer; font-size: 1rem; font-weight: 800; border-radius: 6px; margin-top: 15px; box-shadow: 0 4px 6px rgba(214, 40, 40, 0.3); }
        .calc-button:hover { background: #b51717; transform: translateY(-1px); }
        .tabs { display: flex; background: #e9ecef; border-radius: 6px; padding: 3px; margin-bottom: 15px; }
        .tab { flex: 1; text-align: center; padding: 8px; cursor: pointer; font-weight: 700; color: #666; border-radius: 4px; transition: 0.2s; font-size: 0.8rem; }
        .tab.active { background: white; color: var(--primary); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

        /* Tablas y especiales */
        table { width: 100%; border-collapse: separate; border-spacing: 0; margin-top: 5px; }
        th { text-align: left; color: #a8dadc; border-bottom: 2px solid #457b9d; padding: 5px; font-weight: 600; }
        td { padding: 5px; border-bottom: 1px solid #365b77; }
        .danger { color: #ff4d4d; font-weight: bold; } .warning { color: #ffd166; font-weight: bold; } .ok { color: #06d6a0; font-weight: bold; }
        .tire-inputs input { text-align: center; font-weight: bold; color: var(--dark); }
        .cb-label { display: flex; align-items: center; cursor: pointer; font-weight: bold; color: var(--primary); }
        .cb-label input { margin-right: 8px; width: 18px; height: 18px; }
    </style>
</head>
<body>

    <div class="sidebar">
        <h2>Simulador Suspensión FSAE</h2>

        <div class="input-group" style="background: #e3f2fd; border-color: #bbdefb;">
            <div class="row">
                <label>VISTA 3D:</label>
                <select id="viewMode" onchange="calculateAndPlot()" style="font-weight:bold; flex:2;">
                    <option value="full" selected>Vehículo Completo (4 Ruedas + Chasis)</option>
                    <option value="both">Solo Suspensión (Izq. Del+Tras)</option>
                    <option value="front">Solo Delantera (Izq.)</option>
                    <option value="rear">Solo Trasera (Izq.)</option>
                </select>
            </div>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('front')">Delantera (L)</div>
            <div class="tab" onclick="switchTab('rear')">Trasera (L)</div>
        </div>
        <div id="active-inputs-container" class="input-group"></div>

        <span class="section-header">PARÁMETROS DEL VEHÍCULO</span>
        <div class="input-group">
            <h4>Dinámica</h4>
            <div class="row"><label>G Frenado:</label><input type="number" id="g_braking" value="1.7" step="0.1"></div>
            <div class="row"><label>G Aceleración:</label><input type="number" id="g_accel" value="1.2" step="0.1"></div>
            <div class="row"><label>G Lateral:</label><input type="number" id="g_cornering" value="2.0" step="0.1"></div>
            <div class="row"><label>G Bump:</label><input type="number" id="g_bump" value="3.0" step="0.1"></div>
            <div class="row"><label>Mu Long / Lat:</label>
                <div class="coord-inputs"><input type="number" id="mu_long" value="1.0" step="0.1"><input type="number" id="mu_lat" value="1.0" step="0.1"></div></div>

            <h4>Dimensiones y Masa</h4>
            <div class="row"><label>Wheelbase (mm):</label><input type="number" id="wheelbase" value="1650"></div>
            <div class="row"><label>Trocha Del. (mm):</label><input type="number" id="track_front" value="1200"></div>
            <div class="row"><label>Altura CG (mm):</label><input type="number" id="cg_height" value="350"></div>
            <div class="row"><label>Masa Total (kg):</label><input type="number" id="m_total" value="365"></div>
            <div class="row"><label>% Peso Frontal:</label><input type="number" id="weight_dist_front" value="0.4" step="0.01"></div>
            <div class="row"><label>No Susp. (Del/Tras):</label>
                <div class="coord-inputs"><input type="number" id="unsprung_f" value="28"><input type="number" id="unsprung_r" value="28"></div></div>
        </div>

        <span class="section-header">RUEDAS Y MATERIALES</span>
        <div class="input-group">
            <h4>Neumático y Llanta</h4>
            <div class="row"><label>Medida:</label>
                <div class="coord-inputs tire-inputs">
                    <input type="number" id="tire_w_inp" value="175"><span style="padding:4px; font-weight:bold;">/</span>
                    <input type="number" id="tire_ar_inp" value="50"><span style="padding:4px; font-weight:bold;">R</span>
                    <input type="number" id="rim_d_inp" value="13"></div></div>
            <div class="row"><label style="color:var(--primary); font-weight:bold;">Offset (mm):</label>
                <input type="number" id="wheel_offset" value="45" style="border: 2px solid var(--primary); font-weight:bold;"></div>
            
            <div class="row" style="margin-top:8px;">
                <label class="cb-label" for="transparent_tires">
                    <input type="checkbox" id="transparent_tires" onchange="calculateAndPlot()">Ruedas Transparentes
                </label>
            </div>

            <h4>Tubos (SAE 1026) & Colores</h4>
            <div class="row"><label>Sy (MPa) / E (GPa):</label>
                <div class="coord-inputs"><input type="number" id="mat_yield" value="310"><input type="number" id="mat_E" value="210"></div></div>
            <div class="row"><label>OD / ID (mm):</label>
                <div class="coord-inputs"><input type="number" id="tube_od" value="20"><input type="number" id="tube_id" value="0"></div></div>
            <div class="row"><label>FS Objetivo:</label><input type="number" id="sf_target" value="3.5" step="0.1"></div>
            <div class="row"><label>Comp. / Trac.:</label>
                <div class="coord-inputs"><input type="color" id="color_comp" value="#0088ff"><input type="color" id="color_tens" value="#ff0000"></div></div>
        </div>

        <span class="section-header">TRANSMISIÓN (Solo Trasera)</span>
        <div class="input-group">
            <div class="row"><label>Torque Motor (Nm):</label><input type="number" id="eng_torque" value="120"></div>
            <div class="row"><label>Relación / Efic.:</label>
                <div class="coord-inputs"><input type="number" id="gear_ratio" value="4.0"><input type="number" id="drivetrain_eff" value="0.95" step="0.01"></div></div>
            <div class="row"><label>Palier OD/ID (mm):</label>
                <div class="coord-inputs"><input type="number" id="palier_od" value="22.0"><input type="number" id="palier_id" value="0.0"></div></div>
        </div>

        <button class="calc-button" onclick="calculateAndPlot()">⚡ ACTUALIZAR SIMULACIÓN</button>
        <br><br>
    </div>

    <div class="main-content">
        <div id="plot3d" class="viz-container"></div>
        <div class="results-panel">
            <div id="results-output" style="padding-top:20px; text-align:center; color:#aaa;">Cargando...</div>
        </div>
    </div>

<script>
    // ==========================================
    // 1. DATOS E INPUTS
    // ==========================================
    let editingAxle = 'front';
    const val = (id) => parseFloat(document.getElementById(id).value) || 0;
    const col = (id) => document.getElementById(id).value;

    // HARDPOINTS (LADO IZQUIERDO LOCAL)
    const vehicleData = {
        front: {
            tire_center: [0.0, 0.58675, 0.2525],
            lwb_f: [-0.07990, 0.26455, 0.12523], lwb_r: [0.07990, 0.26455, 0.12523], lwb_u: [0.0, 0.58434, 0.14852],
            uwb_f: [-0.05435, 0.24249, 0.28878], uwb_r: [0.093, 0.24249, 0.27284], uwb_u: [0.0301, 0.55383, 0.35648],
            push_c: [0.0, 0.2, 0.5], push_u: [0.0, 0.5, 0.25],
            tie_c: [-0.100, 0.270, 0.160], tie_u: [-0.100, 0.520, 0.160],
            p_trail_mm: 30.0
        },
        rear: {
            tire_center: [0.0, 0.58675, 0.2525],
            lwb_f: [-0.07990, 0.26455, 0.12523], lwb_r: [0.07990, 0.26455, 0.12523], lwb_u: [0.0, 0.58434, 0.14852],
            uwb_f: [-0.05435, 0.24249, 0.28878], uwb_r: [0.093, 0.24249, 0.27284], uwb_u: [0.0301, 0.55383, 0.35648],
            push_c: [0.0, 0.2, 0.5], push_u: [0.0, 0.5, 0.25],
            tie_c: [-0.100, 0.270, 0.160], tie_u: [-0.100, 0.520, 0.160],
            p_trail_mm: 30.0
        }
    };

    function switchTab(axle) {
        editingAxle = axle;
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        event.target.classList.add('active');
        renderInputs();
    }

    function renderInputs() {
        const d = vehicleData[editingAxle];
        const container = document.getElementById('active-inputs-container');
        container.innerHTML = `<h4>Hardpoints ${editingAxle.toUpperCase()} [X, Y, Z]</h4>`;
        const points = {
            'tire_center': 'Centro Rueda', 'lwb_f': 'LWB Chas F', 'lwb_r': 'LWB Chas R', 'lwb_u': 'LWB Uprt',
            'uwb_f': 'UWB Chas F', 'uwb_r': 'UWB Chas R', 'uwb_u': 'UWB Uprt',
            'push_c': 'Push Chas', 'push_u': 'Push Uprt',
            'tie_c': editingAxle==='front'?'Tie Chas':'Toe Chas', 'tie_u': editingAxle==='front'?'Tie Uprt':'Toe Uprt'
        };
        for (const [key, label] of Object.entries(points)) {
            container.innerHTML += `<div class="row"><label>${label}</label><div class="coord-inputs">
                <input type="number" value="${d[key][0]}" step="0.005" onchange="updateData('${key}',0,this.value)">
                <input type="number" value="${d[key][1]}" step="0.005" onchange="updateData('${key}',1,this.value)">
                <input type="number" value="${d[key][2]}" step="0.005" onchange="updateData('${key}',2,this.value)">
            </div></div>`;
        }
        container.innerHTML += `<div class="row" style="margin-top:5px; border-top:1px solid #eee; padding-top:5px;">
            <label>Pneu. Trail (mm):</label><input type="number" value="${d.p_trail_mm}" onchange="updateScalar('p_trail_mm',this.value)"></div>`;
    }
    function updateData(k,i,v){vehicleData[editingAxle][k][i]=parseFloat(v);}
    function updateScalar(k,v){vehicleData[editingAxle][k]=parseFloat(v);}

    function getTireDims() {
        const w = val('tire_w_inp'), ar = val('tire_ar_inp')/100, rimD_inch = val('rim_d_inp');
        const rimOD_mm = rimD_inch * 25.4;
        const sidewall_H_mm = w * ar;
        const tireOD_mm = rimOD_mm + (2 * sidewall_H_mm);
        return { tire_od: tireOD_mm, tire_width: w, rim_od: rimOD_mm, sidewall_h: sidewall_H_mm };
    }

    // ==========================================
    // 2. MOTOR MATEMÁTICO (SOLVER)
    // ==========================================
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]]; 
    const norm=(v)=>Math.sqrt(v[0]**2+v[1]**2+v[2]**2); 
    const normalize=(v)=>{const n=norm(v);return n===0?[0,0,0]:[v[0]/n,v[1]/n,v[2]/n];};
    const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];

    function solveLinearSystem(A,B){let n=B.length;let M=A.map(r=>[...r]);let x=[...B];for(let i=0;i<n;i++){let max=Math.abs(M[i][i]),row=i;for(let k=i+1;k<n;k++){if(Math.abs(M[k][i])>max){max=Math.abs(M[k][i]);row=k;}}for(let k=i;k<n;k++){let t=M[row][k];M[row][k]=M[i][k];M[i][k]=t;}let t=x[row];x[row]=x[i];x[i]=t;for(let k=i+1;k<n;k++){let c=-M[k][i]/M[i][i];for(let j=i;j<n;j++){if(i===j)M[k][j]=0;else M[k][j]+=c*M[i][j];}x[k]+=c*x[i];}}let res=new Array(n).fill(0);for(let i=n-1;i>-1;i--){let s=0;for(let j=i+1;j<n;j++)s+=M[i][j]*res[j];res[i]=(x[i]-s)/M[i][i];}return res;}

    function calculateAxle(axleType, data, inputs) {
        const g=9.81; const tc=data.tire_center;
        
        const vl_f=normalize(sub(data.lwb_u,data.lwb_f)), vl_r=normalize(sub(data.lwb_u,data.lwb_r));
        const vu_f=normalize(sub(data.uwb_u,data.uwb_f)), vu_r=normalize(sub(data.uwb_u,data.uwb_r));
        const vp=normalize(sub(data.push_u,data.push_c)), vt=normalize(sub(data.tie_u,data.tie_c));

        const total_m = inputs.m_total; const unsprung = (2*inputs.unsprung_f)+(2*inputs.unsprung_r);
        const suspended = total_m - unsprung; let mass_corner=0;

        if(axleType==='front'){
            const susp_f = suspended * inputs.weight_dist_front;
            const static_f = (susp_f/2) + inputs.unsprung_f;
            const trans_lo = (total_m*inputs.g_braking*inputs.cg_height)/inputs.wheelbase;
            const dyn_f = (static_f*2)+trans_lo;
            const trans_la = (dyn_f*inputs.g_cornering*inputs.cg_height)/inputs.track_front;
            mass_corner = (dyn_f/2)+trans_la;
        }else{
            const susp_r = suspended*(1-inputs.weight_dist_front);
            const static_r = (susp_r/2) + inputs.unsprung_r;
            const trans_lo = (total_m*inputs.g_accel*inputs.cg_height)/inputs.wheelbase;
            const dyn_r = (static_r*2)+trans_lo;
            const trans_la = (dyn_r*inputs.g_cornering*inputs.cg_height)/inputs.track_front;
            mass_corner = (dyn_r/2)+trans_la;
        }

        const Fz = mass_corner*g*inputs.g_bump;
        let Fx = Math.min(mass_corner*g*(axleType==='front'?inputs.g_braking:inputs.g_accel), Fz*inputs.mu_long);
        if(axleType==='front') Fx*=-1;
        const Fy = Math.min(mass_corner*g*inputs.g_cornering, Fz*inputs.mu_lat);
        const F_g = [Fx,Fy,Fz];

        const cp_eff = [tc[0]-(data.p_trail_mm/1000), tc[1], 0.0];
        const r_ground = sub(cp_eff, tc);
        const M_g = cross(r_ground, F_g);
        let trqRem=0; if(axleType==='rear'){ trqRem=M_g[1]; M_g[1]=0; }

        const rl=sub(data.lwb_u,tc), ru=sub(data.uwb_u,tc), rp=sub(data.push_u,tc), rt=sub(data.tie_u,tc);
        const ml_f=cross(rl,vl_f), ml_r=cross(rl,vl_r), mu_f=cross(ru,vu_f), mu_r=cross(ru,vu_r), mp=cross(rp,vp), mt=cross(rt,vt);

        const A=[
            [vl_f[0],vl_r[0],vu_f[0],vu_r[0],vp[0],vt[0]], [vl_f[1],vl_r[1],vu_f[1],vu_r[1],vp[1],vt[1]], [vl_f[2],vl_r[2],vu_f[2],vu_r[2],vp[2],vt[2]],
            [ml_f[0],ml_r[0],mu_f[0],mu_r[0],mp[0],mt[0]], [ml_f[1],ml_r[1],mu_f[1],mu_r[1],mp[1],mt[1]], [ml_f[2],ml_r[2],mu_f[2],mu_r[2],mp[2],mt[2]]
        ];
        const B=[-F_g[0],-F_g[1],-F_g[2],-M_g[0],-M_g[1],-M_g[2]];
        let res=[0,0,0,0,0,0]; try{res=solveLinearSystem(A,B);}catch(e){console.error(e);}
        return {forces:res, loads:{Fx,Fy,Fz}, geo:data, massCorner:mass_corner, trqRem};
    }

    // ==========================================
    // 3. VISUALIZACIÓN 3D REALISTA V4 (Bordes Redondeados)
    // ==========================================
    function createRealisticWheelV4(center, tireDims, offset, upLow, upUpp, opacity) {
        const traces = [];
        const rTire = tireDims.tire_od/2000;
        const rRim = tireDims.rim_od/2000;
        const w = tireDims.tire_width/1000;
        const off = offset/1000;
        
        const kp = sub(upUpp, upLow);
        const camber = -Math.atan2(kp[1], kp[2]); 
        const rot = (y,z) => [ y*Math.cos(camber) - z*Math.sin(camber), y*Math.sin(camber) + z*Math.cos(camber) ];

        const makeSurf = (radiusFunc, widthFunc, color, metallic, name, yDomain=[0,1]) => {
            const theta=[], y=[], x_s=[], y_s=[], z_s=[];
            const steps=36, w_steps=6;
            for(let i=0; i<=steps; i++) theta.push((i/steps)*2*Math.PI);
            for(let i=0; i<=w_steps; i++) y.push(yDomain[0] + (i/w_steps)*(yDomain[1]-yDomain[0]));
            
            for(let i=0; i<y.length; i++) {
                let rX=[], rY=[], rZ=[];
                const curY_local = widthFunc(y[i]);
                const curR = radiusFunc(y[i]);
                for(let j=0; j<theta.length; j++) {
                    const bx = curR * Math.cos(theta[j]);
                    const bz = curR * Math.sin(theta[j]);
                    const [ry, rz] = rot(curY_local, bz);
                    rX.push(center[0] + bx);
                    rY.push(center[1] + ry);
                    rZ.push(center[2] + rz);
                }
                x_s.push(rX); y_s.push(rY); z_s.push(rZ);
            }
            return { type:'surface', x:x_s, y:y_s, z:z_s, colorscale:[[0,color],[1,color]], showscale:false, 
                     lighting:{ambient:0.4, diffuse:0.8, specular:metallic?1.5:0.05, roughness:metallic?0.3:0.9}, name, hoverinfo:'skip', opacity };
        };

        // 1. Banda de Rodadura (Tread) - Plana
        const treadW_ratio = 0.85; 
        const treadR = (t) => rTire;
        const treadY = (t) => w * (t - 0.5) * treadW_ratio;
        traces.push(makeSurf(treadR, treadY, '#1a1a1a', false, 'Banda Rodadura'));

        // 2. Paredes Laterales Redondeadas (Sidewalls con curva)
        const makeCurvedSidewall = (side, name) => { // side: -1 (out) or 1 (in)
            const swR = (t) => rRim + (rTire-rRim) * Math.sin(t * Math.PI/2); // Curva sinusoidal para el radio
            const swY = (t) => (side * w/2) * (1 - treadW_ratio * Math.cos(t * Math.PI/2)); // Curva para el ancho
            return makeSurf(swR, swY, '#222222', false, name);
        }
        traces.push(makeCurvedSidewall(-1, 'Sidewall Out'));
        traces.push(makeCurvedSidewall(1, 'Sidewall In'));

        // 3. Barril de la Llanta
        const rimR = (t) => rRim;
        const rimY = (t) => w * (t - 0.5);
        traces.push(makeSurf(rimR, rimY, '#999999', true, 'Barril Llanta'));

        // 4. Plato de la Llanta (Face) en el Offset
        const hubR = 0.04; 
        const faceR = (t) => hubR * (1-t) + rRim * t; 
        const faceY = (t) => off;
        traces.push(makeSurf(faceR, faceY, '#a0a0a0', true, 'Cara Llanta'));

        return traces;
    }

    // ==========================================
    // 4. GENERACIÓN DE CHASIS Y ESPEJADO
    // ==========================================
    function mirrorY(p) { return [p[0], -p[1], p[2]]; }

    function generateChassis(gf, gr, wb) {
        const traces = [];
        const line = (p1, p2) => ({ type:'scatter3d', mode:'lines', x:[p1[0],p2[0]], y:[p1[1],p2[1]], z:[p1[2],p2[2]], line:{color:'#7f8c8d', width:3}, hoverinfo:'skip' });
        const posR = (p) => [p[0]+wb, p[1], p[2]];

        // Bulkhead Delantero (Conecta los puntos internos L y R)
        traces.push(line(gf.lwb_f, mirrorY(gf.lwb_f))); traces.push(line(gf.lwb_r, mirrorY(gf.lwb_r)));
        traces.push(line(gf.uwb_f, mirrorY(gf.uwb_f))); traces.push(line(gf.uwb_r, mirrorY(gf.uwb_r)));
        // Bulkhead Trasero
        traces.push(line(posR(gr.lwb_f), mirrorY(posR(gr.lwb_f)))); traces.push(line(posR(gr.lwb_r), mirrorY(posR(gr.lwb_r))));
        traces.push(line(posR(gr.uwb_f), mirrorY(posR(gr.uwb_f)))); traces.push(line(posR(gr.uwb_r), mirrorY(posR(gr.uwb_r))));
        // Estructura Lateral (Conecta adelante con atrás)
        traces.push(line(gf.lwb_r, posR(gr.lwb_f))); traces.push(line(mirrorY(gf.lwb_r), mirrorY(posR(gr.lwb_f))));
        traces.push(line(gf.uwb_r, posR(gr.uwb_f))); traces.push(line(mirrorY(gf.uwb_r), mirrorY(posR(gr.uwb_f))));

        return traces;
    }

    function generateMirroredTraces(res, xOff, tireDims, offset, co, lbl, opacity) {
        // Clona y espeja la geometría en Y
        const gMirrored = {};
        for(const key in res.geo) gMirrored[key] = typeof res.geo[key] === 'object' ? mirrorY(res.geo[key]) : res.geo[key];
        // El offset también se invierte para el lado derecho
        return generateTraces({geo:gMirrored, forces:res.forces}, xOff, tireDims, -offset, co, lbl, opacity);
    }

    // ==========================================
    // 5. CONTROLADOR PRINCIPAL
    // ==========================================
    function calculateAndPlot() {
        const inputs = {
            g_braking: val('g_braking'), g_accel: val('g_accel'), g_cornering: val('g_cornering'), g_bump: val('g_bump'),
            mu_long: val('mu_long'), mu_lat: val('mu_lat'), wheelbase: val('wheelbase')/1000,
            track_front: val('track_front')/1000, cg_height: val('cg_height')/1000, m_total: val('m_total'),
            weight_dist_front: val('weight_dist_front'), unsprung_f: val('unsprung_f'), unsprung_r: val('unsprung_r')
        };
        const tireDims = getTireDims();
        const offset = val('wheel_offset');
        const colors = { comp: col('color_comp'), tens: col('color_tens') };
        const viewMode = document.getElementById('viewMode').value;
        const tireOpacity = document.getElementById('transparent_tires').checked ? 0.3 : 1.0;

        let plots = [], html = "";

        // Cálculo siempre se hace para mostrar resultados en tabla
        const resF = calculateAxle('front', vehicleData.front, inputs);
        const resR = calculateAxle('rear', vehicleData.rear, inputs);

        if(viewMode === 'full') {
             plots = plots.concat(generateChassis(vehicleData.front, vehicleData.rear, inputs.wheelbase));
             // Lado Izquierdo
             plots = plots.concat(generateTraces(resF, 0, tireDims, offset, colors, "FL", tireOpacity));
             plots = plots.concat(generateTraces(resR, inputs.wheelbase, tireDims, offset, colors, "RL", tireOpacity));
             // Lado Derecho (Espejado)
             plots = plots.concat(generateMirroredTraces(resF, 0, tireDims, offset, colors, "FR", tireOpacity));
             plots = plots.concat(generateMirroredTraces(resR, inputs.wheelbase, tireDims, offset, colors, "RR", tireOpacity));
             html += generateTable("SUSP. DELANTERA (Por Lado)", resF, 'front');
             html += generateTable("SUSP. TRASERA (Por Lado)", resR, 'rear');
        } else if(viewMode === 'both') {
             plots = plots.concat(generateTraces(resF, 0, tireDims, offset, colors, "Front", tireOpacity));
             plots = plots.concat(generateTraces(resR, inputs.wheelbase, tireDims, offset, colors, "Rear", tireOpacity));
             html += generateTable("SUSP. DELANTERA", resF, 'front');
             html += generateTable("SUSP. TRASERA", resR, 'rear');
        } else if(viewMode === 'front') {
             plots = plots.concat(generateTraces(resF, 0, tireDims, offset, colors, "Front", tireOpacity));
             html += generateTable("SUSP. DELANTERA", resF, 'front');
        } else if(viewMode === 'rear') {
             plots = plots.concat(generateTraces(resR, inputs.wheelbase, tireDims, offset, colors, "Rear", tireOpacity));
             html += generateTable("SUSP. TRASERA", resR, 'rear');
        }

        if(viewMode !== 'front') html += calcPowertrain(resR.loads.Fx, tireDims.tire_od);

        document.getElementById('results-output').innerHTML = html;
        
        const layout = {
            margin:{l:0,r:0,b:0,t:0}, paper_bgcolor:'#dae3e7', plot_bgcolor:'#dae3e7',
            scene: {
                aspectmode: "data", xaxis:{title:'X', backgroundcolor:'#d0dce0'}, yaxis:{title:'Y', backgroundcolor:'#d0dce0'}, zaxis:{title:'Z', backgroundcolor:'#e0e8ec'},
                camera: {eye:{x:2.0,y:-2.0,z:1.2}, up:{x:0,y:0,z:1}, center:{x:0,y:0,z:-0.3}}, dragmode: 'orbit'
            }, showlegend: true, legend:{x:0,y:1,bgcolor:'rgba(255,255,255,0.5)'}
        };
        Plotly.react('plot3d', plots, layout, {displayModeBar: true});
    }

    function generateTraces(res, xOff, tireDims, offset, co, lbl, opacity) {
        const g=res.geo; const f=res.forces; const pos=(p)=>[p[0]+xOff,p[1],p[2]];
        const links=[
            {n:"LWB F",f:f[0],p1:g.lwb_f,p2:g.lwb_u},{n:"LWB R",f:f[1],p1:g.lwb_r,p2:g.lwb_u},
            {n:"UWB F",f:f[2],p1:g.uwb_f,p2:g.uwb_u},{n:"UWB R",f:f[3],p1:g.uwb_r,p2:g.uwb_u},
            {n:"Pushrod",f:f[4],p1:g.push_c,p2:g.push_u},{n:lbl.includes('Front')||lbl.includes('F')?"Tie Rod":"Toe Link",f:f[5],p1:g.tie_c,p2:g.tie_u}
        ];
        const traces = links.map(l=>{
            const p1=pos(l.p1), p2=pos(l.p2); const absF=Math.abs(l.f);
            return { type:'scatter3d', mode:'lines+markers', x:[p1[0],p2[0]], y:[p1[1],p2[1]], z:[p1[2],p2[2]],
                line:{color:l.f>0?co.comp:co.tens, width:Math.max(4,Math.min(14,absF/1000))},
                marker:{size:3,color:'#222'}, name:`${lbl} ${l.n}`, hoverinfo:'text', text:`${l.n}: ${l.f.toFixed(0)} N`, opacity: opacity };
        });
        traces.push({type:'scatter3d', mode:'markers', x:[pos(g.tire_center)[0]], y:[pos(g.tire_center)[1]], z:[0], marker:{symbol:'cross',size:5,color:'#333'}, name:'Suelo', hoverinfo:'skip'});
        
        const wheel = createRealisticWheelV4(pos(g.tire_center), tireDims, offset, pos(g.lwb_u), pos(g.uwb_u), opacity);
        wheel.forEach(t => t.name = lbl + ' ' + t.name);
        return [...traces, ...wheel];
    }

    function generateTable(title, res, type) {
        const names = type==='front' ? ["LWB Front","LWB Rear","UWB Front","UWB Rear","Pushrod","Tie Rod"] : ["LWB Front","LWB Rear","UWB Front","UWB Rear","Pushrod","Toe Link"];
        const yieldS=val('mat_yield'), E=val('mat_E')*1e9, od=val('tube_od')/1000, id=val('tube_id')/1000, sf=val('sf_target');
        const area=(Math.PI/4)*(od**2-id**2), I=(Math.PI/64)*(od**4-id**4);

        let html=`<div class="result-block"><h3>${title}</h3><table><tr><th>Barra</th><th>Fuerza</th><th>MPa</th><th>FS Y</th><th>FS B</th></tr>`;
        res.forces.forEach((f,i)=>{
            const s=f>0?"C":"T", stress=(Math.abs(f)/area)/1e6, fsY=yieldS/stress;
            let fsB="-", bc="";
            if(f>0){
                const p1=Object.values(res.geo)[i*3+1], p2=Object.values(res.geo)[i*3+3];
                if(p1&&p2){ const L=norm(sub(p1,p2)), Pcr=(Math.PI**2*E*I)/(L**2), fb=Pcr/f; fsB=fb.toFixed(1); if(fb<sf) bc=fb<1?"danger":"warning"; }
            }
            html+=`<tr><td>${names[i]}</td><td style="font-weight:bold; color:${f>0?col('color_comp'):col('color_tens')}">${f.toFixed(0)}</td><td>${stress.toFixed(1)}</td><td class="${fsY<sf?"warning":"ok"}">${fsY.toFixed(1)}</td><td class="${bc}">${fsB}</td></tr>`;
        });
        return html+`</table><div class="result-footer">Cargas Parche (Por Rueda): Fx=${res.loads.Fx.toFixed(0)}, Fy=${res.loads.Fy.toFixed(0)}, Fz=${res.loads.Fz.toFixed(0)}</div></div><br>`;
    }

    function calcPowertrain(Fx, tireOD_mm){
        const T_eng=val('eng_torque'), gr=val('gear_ratio'), eff=val('drivetrain_eff'), pod=val('palier_od')/1000, pid=val('palier_id')/1000, rTire=tireOD_mm/2000;
        const T_whl=T_eng*gr*eff, T_grip=Fx*rTire, T_des=Math.min(T_whl,T_grip);
        const Sy_shear=900*0.58, J=(Math.PI/32)*(pod**4-pid**4), tau=(T_des*pod/2)/J/1e6, fs=Sy_shear/tau;
        return `<div class="result-block" style="border-top:4px solid #fca311"><h3>TREN DE POTENCIA</h3><table><tr><th>Item</th><th>Valor</th></tr>
        <tr><td>Torque Diseño</td><td>${T_des.toFixed(1)} Nm</td></tr>
        <tr><td>FS Torsión</td><td class="${fs<3.5?"warning":"ok"}"><strong>${fs.toFixed(2)}</strong></td></tr></table></div>`;
    }

    switchTab('front');
    renderInputs();
    setTimeout(calculateAndPlot, 800);
</script>
</body>
</html>