<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Suspensión FSAE 3D</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        :root { --primary: #e63946; --dark: #1d3557; --light: #f1faee; --accent: #457b9d; }
        body { font-family: 'Segoe UI', sans-serif; margin: 0; padding: 0; background: #f8f9fa; display: flex; height: 100vh; overflow: hidden; }
        
        /* Layout */
        .sidebar { width: 380px; background: #fff; overflow-y: auto; padding: 20px; box-shadow: 2px 0 10px rgba(0,0,0,0.1); border-right: 1px solid #ddd; z-index: 10; display: flex; flex-direction: column; }
        .main-content { flex: 1; display: flex; flex-direction: column; position: relative; }
        .viz-container { flex: 1; position: relative; background: #fff; }
        
        /* Panel Inferior de Resultados */
        .results-panel { 
            height: 250px; 
            background: #1d3557; 
            color: white; 
            overflow-y: auto; 
            padding: 15px 25px; 
            font-family: 'Consolas', monospace; 
            font-size: 0.9em;
            border-top: 4px solid var(--primary);
        }

        /* Estilos UI */
        h2 { color: var(--dark); margin-top: 0; font-size: 1.5rem; border-bottom: 2px solid var(--primary); padding-bottom: 10px; }
        h4 { margin: 15px 0 5px 0; color: #555; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; }
        
        .input-group { background: #f4f6f8; padding: 10px; border-radius: 6px; border: 1px solid #e1e4e8; margin-bottom: 10px; }
        
        .row { display: flex; gap: 10px; align-items: center; margin-bottom: 5px; }
        .row label { flex: 1; font-size: 0.85rem; font-weight: 600; color: #333; }
        .row input { flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; width: 100%; }
        
        .coord-inputs { display: flex; gap: 4px; }
        .coord-inputs input { width: 60px; text-align: center; font-family: monospace; }

        button { width: 100%; padding: 12px; background: var(--primary); color: white; border: none; cursor: pointer; font-size: 1rem; font-weight: bold; border-radius: 6px; transition: 0.2s; margin-top: 10px; box-shadow: 0 4px 6px rgba(230, 57, 70, 0.3); }
        button:hover { background: #d62828; transform: translateY(-1px); }

        /* Tabs de Selección de Eje para editar */
        .tabs { display: flex; background: #e9ecef; border-radius: 6px; padding: 4px; margin-bottom: 15px; }
        .tab { flex: 1; text-align: center; padding: 8px; cursor: pointer; font-weight: 600; color: #666; border-radius: 4px; transition: 0.2s; }
        .tab.active { background: white; color: var(--dark); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        /* Selector de Vista */
        .view-selector { margin-bottom: 15px; text-align: center; }
        .view-options { display: flex; justify-content: center; gap: 10px; }
        .radio-label { font-size: 0.9rem; cursor: pointer; display: flex; align-items: center; gap: 5px; }

        /* Tablas */
        table { width: 100%; border-collapse: collapse; margin-top: 5px; }
        th { text-align: left; color: #a8dadc; border-bottom: 1px solid #457b9d; padding: 5px; }
        td { padding: 4px 5px; border-bottom: 1px solid #365b77; }
        .danger { color: #ff6b6b; font-weight: bold; }
        .warning { color: #feca57; font-weight: bold; }
        .ok { color: #51cf66; font-weight: bold; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>

    <div class="sidebar">
        <h2>Suspensión FSAE</h2>

        <div class="input-group">
            <div class="row">
                <label>Vista 3D:</label>
                <select id="viewMode" onchange="calculateAndPlot()" style="flex:1; padding:5px;">
                    <option value="front">Solo Delantera</option>
                    <option value="rear">Solo Trasera</option>
                    <option value="both" selected>Vehículo Completo</option>
                </select>
            </div>
            <div class="row">
                <label>Wheelbase (mm):</label>
                <input type="number" id="wheelbase" value="1650">
            </div>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('front')">Editar Delantera</div>
            <div class="tab" onclick="switchTab('rear')">Editar Trasera</div>
        </div>

        <div id="active-inputs-container">
            </div>

        <div class="input-group">
            <h4>Parámetros Generales</h4>
            <div class="row"><label>Maniobra (G Fren/Acel):</label><input type="number" id="g_long" value="1.7" step="0.1"></div>
            <div class="row"><label>Maniobra (G Lat):</label><input type="number" id="g_lat" value="2.0" step="0.1"></div>
            <div class="row"><label>Maniobra (G Bump):</label><input type="number" id="g_bump" value="3.0" step="0.1"></div>
        </div>

        <div class="input-group">
            <h4>Neumático y Llanta</h4>
            <div class="row"><label>OD Neumático (mm):</label><input type="number" id="tire_od" value="520"></div>
            <div class="row"><label>Ancho Goma (mm):</label><input type="number" id="tire_width" value="205"></div>
            <div class="row"><label>OD Llanta (mm):</label><input type="number" id="rim_od" value="330"></div>
            <div class="row"><label>Pneu. Trail (mm):</label><input type="number" id="p_trail" value="30"></div>
        </div>

        <button onclick="calculateAndPlot()">CALCULAR Y ACTUALIZAR</button>
        <br><br>
    </div>

    <div class="main-content">
        <div id="plot3d" class="viz-container"></div>
        <div class="results-panel">
            <div id="results-output">Resultados pendientes de cálculo...</div>
        </div>
    </div>

<script>
    // ==========================================
    // 1. GESTIÓN DE DATOS Y ESTADO
    // ==========================================
    let editingAxle = 'front'; // Qué inputs estamos mostrando ('front' o 'rear')

    // Base de datos de hardpoints (coordendas locales)
    const vehicleData = {
        front: {
            tire_center: [0.0, 0.58675, 0.2525],
            lwb_f: [-0.07990, 0.26455, 0.12523], lwb_r: [0.07990, 0.26455, 0.12523], lwb_u: [0.0, 0.58434, 0.14852],
            uwb_f: [-0.05435, 0.24249, 0.28878], uwb_r: [0.093, 0.24249, 0.27284], uwb_u: [0.0301, 0.55383, 0.35648],
            push_c: [0.0, 0.2, 0.5], push_u: [0.0, 0.5, 0.25],
            tie_c: [-0.100, 0.270, 0.160], tie_u: [-0.100, 0.520, 0.160]
        },
        rear: {
            // Coordenadas locales (relativas al eje trasero, luego sumamos wheelbase)
            tire_center: [0.0, 0.58675, 0.2525],
            lwb_f: [-0.07990, 0.26455, 0.12523], lwb_r: [0.07990, 0.26455, 0.12523], lwb_u: [0.0, 0.58434, 0.14852],
            uwb_f: [-0.05435, 0.24249, 0.28878], uwb_r: [0.093, 0.24249, 0.27284], uwb_u: [0.0301, 0.55383, 0.35648],
            push_c: [0.0, 0.2, 0.5], push_u: [0.0, 0.5, 0.25],
            tie_c: [-0.100, 0.270, 0.160], tie_u: [-0.100, 0.520, 0.160]
        }
    };

    function switchTab(axle) {
        editingAxle = axle;
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        event.target.classList.add('active');
        renderInputs();
    }

    function renderInputs() {
        const d = vehicleData[editingAxle];
        const container = document.getElementById('active-inputs-container');
        container.innerHTML = `<h4>Geometría ${editingAxle.toUpperCase()} [X, Y, Z] (Local)</h4>`;
        
        const points = {
            'tire_center': 'Centro Rueda',
            'lwb_f': 'LWB Chasis Front', 'lwb_r': 'LWB Chasis Rear', 'lwb_u': 'LWB Upright',
            'uwb_f': 'UWB Chasis Front', 'uwb_r': 'UWB Chasis Rear', 'uwb_u': 'UWB Upright',
            'push_c': 'Pushrod Chasis', 'push_u': 'Pushrod Upright',
            'tie_c': editingAxle==='front'?'Tie Rod Chasis':'Toe Link Chasis', 
            'tie_u': editingAxle==='front'?'Tie Rod Upright':'Toe Link Upright'
        };

        for (const [key, label] of Object.entries(points)) {
            const val = d[key];
            container.innerHTML += `
                <div class="row">
                    <label>${label}</label>
                    <div class="coord-inputs">
                        <input type="number" id="${key}_x" value="${val[0]}" step="0.005" onchange="updateData('${key}', 0, this.value)">
                        <input type="number" id="${key}_y" value="${val[1]}" step="0.005" onchange="updateData('${key}', 1, this.value)">
                        <input type="number" id="${key}_z" value="${val[2]}" step="0.005" onchange="updateData('${key}', 2, this.value)">
                    </div>
                </div>`;
        }
    }

    function updateData(key, index, value) {
        vehicleData[editingAxle][key][index] = parseFloat(value);
    }

    // ==========================================
    // 2. MOTOR MATEMÁTICO (SOLVER)
    // ==========================================
    const sub = (v1, v2) => [v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]];
    const add = (v1, v2) => [v1[0]+v2[0], v1[1]+v2[1], v1[2]+v2[2]];
    const norm = (v) => Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
    const normalize = (v) => { const n = norm(v); return n===0 ? [0,0,0] : [v[0]/n, v[1]/n, v[2]/n]; };
    const cross = (a, b) => [ a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0] ];

    function solveLinearSystem(A, B) {
        let n = B.length;
        // Copia profunda para no mutar originales si se reusan
        let M = A.map(row => [...row]); 
        let x = [...B];

        for (let i = 0; i < n; i++) {
            let maxEl = Math.abs(M[i][i]), maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(M[k][i]) > maxEl) { maxEl = Math.abs(M[k][i]); maxRow = k; }
            }
            for (let k = i; k < n; k++) { let tmp = M[maxRow][k]; M[maxRow][k] = M[i][k]; M[i][k] = tmp; }
            let tmp = x[maxRow]; x[maxRow] = x[i]; x[i] = tmp;

            for (let k = i + 1; k < n; k++) {
                let c = -M[k][i] / M[i][i];
                for (let j = i; j < n; j++) {
                    if (i === j) M[k][j] = 0; else M[k][j] += c * M[i][j];
                }
                x[k] += c * x[i];
            }
        }
        let res = new Array(n).fill(0);
        for (let i = n - 1; i > -1; i--) {
            let sum = 0;
            for (let j = i + 1; j < n; j++) sum += M[i][j] * res[j];
            res[i] = (x[i] - sum) / M[i][i];
        }
        return res;
    }

    function calculateAxle(axleType, data, inputs) {
        // Extraer geometría local
        const tire_c = data.tire_center;
        // Vectores unitarios (Links)
        const v_lwb_f = normalize(sub(data.lwb_u, data.lwb_f));
        const v_lwb_r = normalize(sub(data.lwb_u, data.lwb_r));
        const v_uwb_f = normalize(sub(data.uwb_u, data.uwb_f));
        const v_uwb_r = normalize(sub(data.uwb_u, data.uwb_r));
        const v_push  = normalize(sub(data.push_u, data.push_c));
        const v_tie   = normalize(sub(data.tie_u, data.tie_c));

        // Cargas Estimadas
        const mass_total = 365; // kg
        const g = 9.81;
        let Fx = 0, Fy = 0, Fz = 0;
        
        // Simulación simplificada de transferencia de carga
        if (axleType === 'front') {
            const static_load = (mass_total * 0.4) / 2; // Media masa eje delantero
            const trans_long = (mass_total * inputs.g_long * 0.35) / 1.65 / 2;
            const dynamic_vert = (static_load + trans_long);
            const trans_lat = (dynamic_vert * 2 * inputs.g_lat * 0.35) / 1.20; 
            
            const mass_corner = dynamic_vert + trans_lat;
            Fz = mass_corner * g * inputs.g_bump;
            Fx = -1 * Math.min(mass_corner * g * inputs.g_long, Fz); // Freno
            Fy = Math.min(mass_corner * g * inputs.g_lat, Fz);
        } else {
            const static_load = (mass_total * 0.6) / 2;
            const trans_long = (mass_total * inputs.g_long * 0.35) / 1.65 / 2; // Squat sumando atrás
            const dynamic_vert = (static_load + trans_long);
            const trans_lat = (dynamic_vert * 2 * inputs.g_lat * 0.35) / 1.20;
            
            const mass_corner = dynamic_vert + trans_lat;
            Fz = mass_corner * g * inputs.g_bump;
            Fx = mass_corner * g * inputs.g_long; // Tracción
            Fy = mass_corner * g * inputs.g_lat;
        }
        const F_ground = [Fx, Fy, Fz];

        // Momentos
        const p_trail_m = inputs.p_trail / 1000;
        const cp_geo = [tire_c[0], tire_c[1], 0.0];
        const cp_eff = [tire_c[0] - p_trail_m, tire_c[1], 0.0]; // Aplicamos trail
        
        const r_ground = sub(cp_eff, tire_c);
        const M_ground = cross(r_ground, F_ground);

        if (axleType === 'rear') M_ground[1] = 0; // Eliminar torque tracción en upright

        // Matriz A
        // Orden: LWB_f, LWB_r, UWB_f, UWB_r, Push, Tie
        const r_lwb = sub(data.lwb_u, tire_c);
        const r_uwb = sub(data.uwb_u, tire_c);
        const r_push = sub(data.push_u, tire_c);
        const r_tie = sub(data.tie_u, tire_c);

        const m_lwb_f = cross(r_lwb, v_lwb_f);
        const m_lwb_r = cross(r_lwb, v_lwb_r);
        const m_uwb_f = cross(r_uwb, v_uwb_f);
        const m_uwb_r = cross(r_uwb, v_uwb_r);
        const m_push = cross(r_push, v_push);
        const m_tie = cross(r_tie, v_tie);

        const A = [
            [v_lwb_f[0], v_lwb_r[0], v_uwb_f[0], v_uwb_r[0], v_push[0], v_tie[0]],
            [v_lwb_f[1], v_lwb_r[1], v_uwb_f[1], v_uwb_r[1], v_push[1], v_tie[1]],
            [v_lwb_f[2], v_lwb_r[2], v_uwb_f[2], v_uwb_r[2], v_push[2], v_tie[2]],
            [m_lwb_f[0], m_lwb_r[0], m_uwb_f[0], m_uwb_r[0], m_push[0], m_tie[0]],
            [m_lwb_f[1], m_lwb_r[1], m_uwb_f[1], m_uwb_r[1], m_push[1], m_tie[1]],
            [m_lwb_f[2], m_lwb_r[2], m_uwb_f[2], m_uwb_r[2], m_push[2], m_tie[2]]
        ];
        const B = [-F_ground[0], -F_ground[1], -F_ground[2], -M_ground[0], -M_ground[1], -M_ground[2]];

        let results = [];
        try { results = solveLinearSystem(A, B); } catch(e) { console.error(e); }

        return {
            forces: results, // [LWBf, LWBr, UWBf, UWBr, Push, Tie]
            loads: { Fx, Fy, Fz },
            geo: data // Retornamos la geometría usada
        };
    }

    // ==========================================
    // 3. GRAFICACIÓN 3D AVANZADA
    // ==========================================

    function createSolidWheel(center, radius, width, uprightLower, uprightUpper) {
        // 1. Calcular Orientación de la rueda (Normal vector del plano de la rueda)
        // Usamos la línea Kingpin (LWB_u -> UWB_u) para estimar Camber y KPI
        const kp_vec = normalize(sub(uprightUpper, uprightLower));
        
        // Eje de la rueda (Spindle Axis)
        // Asumimos que el eje de la rueda es perpendicular al Kingpin en el plano YZ (Camber)
        // y perpendicular al eje X global (sin steering para simplificar, o usar Toe si se tuviera)
        // Aproximación rápida: El eje Y de la rueda se inclina según el KPI/Camber.
        
        // Calculamos ángulos de rotación basados en el vector Kingpin
        // El vector Kingpin en FSAE suele estar inclinado hacia adentro (KPI) y atrás (Caster).
        // El vector normal de la rueda (eje de rotación) es aprox perpendicular a Z y al Kingpin projected.
        // Método simplificado: Rotar el cilindro base.
        
        // Ángulo con la vertical (Eje Z) en el plano YZ = Camber negativo
        const dz = uprightUpper[2] - uprightLower[2];
        const dy = uprightUpper[1] - uprightLower[1];
        const camber_angle = -Math.atan2(dy, dz); // Radianes. Si dy es positivo (hacia adentro), camber negativo.

        // Generar malla cilíndrica
        const steps = 32;
        const x = [], y = [], z = [];
        const i = [], j = [], k = []; // Índices triangulación

        // Función para rotar un punto (0, y, z) alrededor del eje X (Camber)
        // El cilindro original está acostado en Y.
        const rotatePoint = (py, pz) => {
            const ny = py * Math.cos(camber_angle) - pz * Math.sin(camber_angle);
            const nz = py * Math.sin(camber_angle) + pz * Math.cos(camber_angle);
            return [ny, nz];
        };

        // Generar vértices tapa externa e interna
        // Tapa Externa (Outer): Y negativo (hacia afuera del coche si Y+ es adentro)
        // NOTA: En este sistema de coord, Y aumenta hacia el centro (track/2). 
        // center[1] es track/2. Wheel width se distribuye.
        
        for (let s = 0; s < steps; s++) {
            const theta = (s / steps) * 2 * Math.PI;
            const rx = radius * Math.cos(theta);
            const rz = radius * Math.sin(theta);
            
            // Offset lateral respecto al centro
            const y_out = -width / 2;
            const y_in  = width / 2;

            // Rotar por Camber
            const [rot_y_out, rot_z_out] = rotatePoint(y_out, rz);
            const [rot_y_in, rot_z_in]   = rotatePoint(y_in, rz);

            // Tapa Externa (Índices 0 a steps-1)
            x.push(center[0] + rx);
            y.push(center[1] + rot_y_out);
            z.push(center[2] + rot_z_out);

            // Tapa Interna (Índices steps a 2*steps-1)
            x.push(center[0] + rx);
            y.push(center[1] + rot_y_in);
            z.push(center[2] + rot_z_in);
        }

        // Crear caras (triángulos)
        // Tapa (Fan) y Pared lateral (Strip)
        // Simplificación: Solo pared lateral y tapas simples
        
        // Pared Lateral
        for (let s = 0; s < steps; s++) {
            const next = (s + 1) % steps;
            const topBase = s;
            const botBase = s + steps;
            const topNext = next;
            const botNext = next + steps;

            // Triangulo 1
            i.push(topBase); j.push(botBase); k.push(topNext);
            // Triangulo 2
            i.push(botBase); j.push(botNext); k.push(topNext);
        }

        // Tapas (Usando un punto central extra o fan logic, para simplificar Plotly mesh3d hull, 
        // usamos 'alphahull' o cerramos manualmente. Aquí dejamos el cilindro hueco visualmente o añadimos centro)
        // Añadimos centros para cerrar tapas
        const idx_center_out = x.length;
        const [cy_out, cz_out] = rotatePoint(-width/2, 0);
        x.push(center[0]); y.push(center[1] + cy_out); z.push(center[2] + cz_out);
        
        const idx_center_in = x.length;
        const [cy_in, cz_in] = rotatePoint(width/2, 0);
        x.push(center[0]); y.push(center[1] + cy_in); z.push(center[2] + cz_in);

        for (let s = 0; s < steps; s++) {
            const next = (s + 1) % steps;
            // Tapa Out
            i.push(s); j.push(next); k.push(idx_center_out);
            // Tapa In
            i.push(s + steps); j.push(idx_center_in); k.push(next + steps);
        }

        return {
            type: 'mesh3d',
            x: x, y: y, z: z,
            i: i, j: j, k: k,
            color: '#222',
            opacity: 0.9,
            flatshading: true,
            name: 'Neumático',
            lighting: {ambient: 0.5, diffuse: 0.5}
        };
    }

    function calculateAndPlot() {
        const viewMode = document.getElementById('viewMode').value;
        const wheelbase = parseFloat(document.getElementById('wheelbase').value) / 1000; // a metros

        const inputs = {
            g_long: parseFloat(document.getElementById('g_long').value),
            g_lat: parseFloat(document.getElementById('g_lat').value),
            g_bump: parseFloat(document.getElementById('g_bump').value),
            p_trail: parseFloat(document.getElementById('p_trail').value),
            tire_od: parseFloat(document.getElementById('tire_od').value),
            tire_width: parseFloat(document.getElementById('tire_width').value)
        };

        let plots = [];
        let htmlResults = "";

        // --- CALCULAR Y GRAFICAR DELANTERA ---
        if (viewMode === 'front' || viewMode === 'both') {
            const resF = calculateAxle('front', vehicleData.front, inputs);
            plots = plots.concat(generateAxleTraces(resF, 0, inputs, "Front")); // Offset X = 0
            htmlResults += generateResultTable("Delantera", resF);
        }

        // --- CALCULAR Y GRAFICAR TRASERA ---
        if (viewMode === 'rear' || viewMode === 'both') {
            const resR = calculateAxle('rear', vehicleData.rear, inputs);
            // Offset X = Wheelbase (si es both) o 0 (si es solo rear view centered)
            // Para "Both", movemos la trasera atrás. Para "Rear", la dejamos en 0 para verla bien.
            const xOffset = (viewMode === 'both') ? wheelbase : 0; 
            plots = plots.concat(generateAxleTraces(resR, xOffset, inputs, "Rear"));
            htmlResults += generateResultTable("Trasera", resR);
        }

        // Renderizar Resultados
        document.getElementById('results-output').innerHTML = htmlResults;

        // Renderizar Gráfico
        const layout = {
            margin: {l:0, r:0, b:0, t:0},
            scene: {
                aspectmode: "data",
                xaxis: {title: 'X (Longitudinal)', showbackground:true, backgroundcolor:'#f0f0f0'},
                yaxis: {title: 'Y (Transversal)', showbackground:true, backgroundcolor:'#f0f0f0'},
                zaxis: {title: 'Z (Vertical)', showbackground:true, backgroundcolor:'#e0e0e0'},
                camera: { eye: {x: 1.5, y: -1.5, z: 0.8}, up: {x:0, y:0, z:1} }
            },
            showlegend: true,
            legend: {x: 0, y: 1}
        };
        Plotly.newPlot('plot3d', plots, layout);
    }

    function generateAxleTraces(res, xOffset, inputs, label) {
        const g = res.geo;
        const f = res.forces;
        const traces = [];

        // Función auxiliar para aplicar offset
        const pos = (p) => [p[0] + xOffset, p[1], p[2]];

        // 1. Tubos
        const links = [
            {n: "LWB F", f: f[0], p1: g.lwb_f, p2: g.lwb_u},
            {n: "LWB R", f: f[1], p1: g.lwb_r, p2: g.lwb_u},
            {n: "UWB F", f: f[2], p1: g.uwb_f, p2: g.uwb_u},
            {n: "UWB R", f: f[3], p1: g.uwb_r, p2: g.uwb_u},
            {n: "Pushrod", f: f[4], p1: g.push_c, p2: g.push_u},
            {n: "Tie/Toe", f: f[5], p1: g.tie_c, p2: g.tie_u}
        ];

        links.forEach(l => {
            const p1 = pos(l.p1);
            const p2 = pos(l.p2);
            const color = l.f > 0 ? '#3498db' : '#e74c3c'; // Azul comp, Rojo trac
            const width = Math.abs(l.f) > 5000 ? 8 : 4; // Más grueso si mucha fuerza

            traces.push({
                type: 'scatter3d', mode: 'lines+markers',
                x: [p1[0], p2[0]], y: [p1[1], p2[1]], z: [p1[2], p2[2]],
                line: {color: color, width: width},
                marker: {size: 3, color: 'black'},
                name: `${label} ${l.n}`,
                hoverinfo: 'text', text: `${label} ${l.n}: ${l.f.toFixed(0)} N`
            });
        });

        // 2. Rueda Sólida 3D
        const wheelCenter = pos(g.tire_center);
        // Puntos de upright para calcular inclinación
        const upLow = pos(g.lwb_u);
        const upUpp = pos(g.uwb_u);
        
        const tireMesh = createSolidWheel(
            wheelCenter, 
            inputs.tire_od/2000, // radio en metros
            inputs.tire_width/1000, 
            upLow, upUpp
        );
        tireMesh.name = `${label} Tire`;
        traces.push(tireMesh);

        // 3. Referencia suelo
        traces.push({
            type: 'scatter3d', mode: 'markers',
            x: [wheelCenter[0]], y: [wheelCenter[1]], z: [0],
            marker: {symbol:'cross', size: 5, color: 'green'},
            name: 'Suelo'
        });

        return traces;
    }

    function generateResultTable(title, res) {
        const names = ["LWB Front", "LWB Rear", "UWB Front", "UWB Rear", "Pushrod", "Tie/Toe"];
        const area = (Math.PI/4) * (20**2); // Tubo 20mm
        const yieldStr = 310;
        
        let html = `<h3>${title}</h3><table>
            <tr><th>Elemento</th><th>Fuerza (N)</th><th>Esfuerzo (MPa)</th><th>FS</th></tr>`;
        
        res.forces.forEach((force, i) => {
            const stress = Math.abs(force) / area;
            const fs = yieldStr / stress;
            let fsClass = "ok";
            if(fs < 1.5) fsClass = "danger";
            else if(fs < 3.5) fsClass = "warning";

            html += `<tr>
                <td>${names[i]}</td>
                <td>${force.toFixed(0)}</td>
                <td>${stress.toFixed(1)}</td>
                <td class="${fsClass}">${fs.toFixed(2)}</td>
            </tr>`;
        });
        html += `</table>
        <div style="font-size:0.85em; margin-top:5px; color:#aaa;">
            Cargas Suelo: Fx=${res.loads.Fx.toFixed(0)}, Fy=${res.loads.Fy.toFixed(0)}, Fz=${res.loads.Fz.toFixed(0)} N
        </div><br>`;
        return html;
    }

    // Inicializar
    renderInputs();
    setTimeout(calculateAndPlot, 500);

</script>
</body>
</html>